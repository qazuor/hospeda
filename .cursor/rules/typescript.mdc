---
description: 
globs: *.ts,*.tsx
alwaysApply: false
---
# TypeScript Rules

- Always enable strict mode (`strict: true`).
- Never use `any` type; prefer explicit and safe types.
- Use literal and union types for clear intent.
- Declare input and output types for all public functions.
- Prefer type aliases and interfaces for complex structures.
- Use utility types to avoid repetition.
- Use `import type` for type imports.


### âœ… Type Safety & Typing

- Always declare **types for all variables, function parameters, and return values**.
- Never use `any`. Use `unknown` if type is truly unknown, and refine with type guards.
- Prefer **`type`** over `interface` for most use cases unless extending objects.
- Use **readonly** and `as const` to enforce immutability where applicable.
- Prefer union types and literal types over magic strings:

```ts
type Status = 'active' | 'archived' | 'deleted';
```

---

### ğŸ§  Function Design

- All functions must be:
  - Strongly typed
  - Short (preferably < 20 LOC)
  - Named with a **verb + purpose**
- Use the **RO-RO pattern**:
  - Receive an object with named parameters
  - Return an object with named results

```ts
type Input = { price: number; taxRate: number };
type Output = { total: number };

const calculateTotal = ({ price, taxRate }: Input): Output => {
  return { total: price * (1 + taxRate) };
};
```

- Use **arrow functions** for simple logic and **named functions** for longer/recursive logic.

---

### ğŸ“¦ Modularization & Exports

- Use **named exports** only â€” no default exports.
- Keep one logical responsibility per file.
- Use `index.ts` to re-export when grouping types, utils, etc.
- Organize types in `@repo/types`, schemas in `@repo/schemas`, and database models in `@repo/db`.

---

### ğŸ§© Types & Enums

- Place reusable enums in `enums/` folder.
- Enums must be well-named, exported, and typed.
- Add a display map if needed, e.g.:

```ts
export enum AccommodationTypeEnum {
  HOTEL = 'HOTEL',
  CABIN = 'CABIN',
  HOSTEL = 'HOSTEL',
}
```

- Use helper types like `WithId`, `WithAudit`, `WithRelations`, etc., from `common/helpers.types.ts`.

---

### ğŸ›¡ï¸ Zod Integration

- Every input/output should have a Zod schema when used for validation, forms, or API.
- The schema must match the TypeScript type exactly â€” no fields should be missing or renamed.
- Add error messages explicitly in Zod schemas.

---

### ğŸ“ Naming Conventions

- âœ… `camelCase` for variables, functions, consts
- âœ… `PascalCase` for types, components, enums, classes
- âœ… `UPPER_CASE` for environment variables and constants
- âœ… `i`, `j` for loops, `err` for errors, `ctx`, `req`, `res` in middleware
- âœ… Use verbs for booleans: `isActive`, `hasError`, `canCreate`

---

### ğŸš« Forbidden Practices

- âŒ `any`, `Function`, `Object`, or `{}`
- âŒ `console.log` in committed code (unless behind `// biome-ignore`)
- âŒ Implicit `any` return or parameters
- âŒ Multiple responsibilities in one file
- âŒ Nesting 3+ levels deep without extracting to helpers

---

### âœ… TL;DR

- Strong typing everywhere.
- Follow RO-RO and clean function design.
- Use named exports only.
- Organize code and types by domain.
- Prefer immutability and Zod validation.
- Make your code readable, predictable, and testable.
